<div align="center">
  <h3 align="center">Cryptography</h3>
  <div>
  <a href="https://bgcp.vercel.app/article/0b99ce80-0dd6-4b3f-8e96-f509474c0ae4">
  <img src="https://img.shields.io/badge/Download PDF (ENGLISH)-black?style=for-the-badge&logoColor=white&color=000000" alt="three.js" />
  </a>
  </div>
</div>

## üöÄ Introdu√ß√£o √† Assinatura Digital com Node.js

Neste tutorial, vamos explorar como implementar assinaturas digitais em Node.js para garantir a autenticidade das mensagens enviadas pelo servidor. A assinatura digital √© fundamental para verificar se a mensagem recebida pelo cliente foi realmente enviada pelo servidor e se ela permaneceu intacta durante a transmiss√£o. Este m√©todo √© amplamente utilizado em comunica√ß√µes seguras, autentica√ß√£o de documentos, e em v√°rias outras aplica√ß√µes que requerem verifica√ß√£o de integridade e autenticidade.

### üåü Principais Caracter√≠sticas:

- **üîí Seguran√ßa Aprimorada**: A assinatura digital adiciona uma camada de seguran√ßa, assegurando que a mensagem √© aut√™ntica.
- **‚úÖ Integridade de Dados**: Garante que a mensagem n√£o foi alterada.
- **üîè Autenticidade**: Confirma a identidade do remetente.
- **üìà N√£o-rep√∫dio**: O remetente n√£o pode negar a autoria da mensagem assinada.

## üõ†Ô∏è Instala√ß√£o

Para este tutorial, voc√™ precisa ter o Node.js instalado. A boa not√≠cia √© que utilizaremos o m√≥dulo `crypto`, que j√° vem embutido no Node.js, ent√£o n√£o h√° necessidade de instala√ß√µes adicionais.

## üìä Uso B√°sico

Vamos come√ßar criando um script simples para gerar um par de chaves (p√∫blica e privada), assinar uma mensagem com a chave privada e, em seguida, verificar essa assinatura com a chave p√∫blica. Este processo demonstra a ess√™ncia da assinatura digital.

### üõ†Ô∏è Gerando o Par de Chaves, Assinando e Verificando Mensagens

1. **Criar um Script para Assinatura Digital**:

Salve o seguinte c√≥digo em um arquivo, por exemplo, `digitalSignature.js`. Este script ilustra como gerar um par de chaves, assinar uma mensagem e verificar a assinatura:

```js
const { generateKeyPair, createSign, createVerify } = require('crypto');

// Gerar par de chaves RSA
generateKeyPair('rsa', {
    modulusLength: 2048, // üõ†Ô∏è Tamanho da chave
}, (err, publicKey, privateKey) => {
    if (err) {
        console.error('Erro ao gerar as chaves üîë:', err);
        return;
    }

    // Mensagem a ser assinada
    const message = "Mensagem secreta ü§´";

    // Criar assinatura
    const sign = createSign('sha256');
    sign.update(message); // üìù Atualiza a mensagem a ser assinada
    sign.end(); // üèÅ Finaliza o input da mensagem

    const signature = sign.sign(privateKey, 'base64'); // üîè Assina com a chave privada
    console.log('Assinatura: üìú', signature);

    // Verificar assinatura
    const verify = createVerify('sha256');
    verify.update(message); // üìù Atualiza com a mesma mensagem
    verify.end(); // üèÅ Finaliza o input da mensagem

    // üïµÔ∏è‚Äç‚ôÇÔ∏è Verifica se a assinatura √© v√°lida com a chave p√∫blica
    const isValid = verify.verify(publicKey, signature, 'base64');
    console.log('A assinatura √© v√°lida? ‚úÖ‚ùå', isValid ? 'Sim ‚úÖ' : 'N√£o ‚ùå');
});
```

2. **Executar o Script**:

Abra um terminal, navegue at√© o diret√≥rio onde voc√™ salvou o arquivo `digitalSignature.js` e execute o seguinte comando:

```bash
node digitalSignature.js
```

Voc√™ ver√° a assinatura gerada no console, seguida pela confirma√ß√£o de que a assinatura √© v√°lida.


### üìà Assinatura Digital para Autenticidade de Mensagens

### Teoria da Assinatura Digital:

üí° A assinatura digital utiliza algoritmos de criptografia assim√©trica para gerar um resumo criptogr√°fico da mensagem, que √© ent√£o assinado usando a chave privada do remetente. O receptor pode verificar esta assinatura com a chave p√∫blica do remetente, assegurando assim a autenticidade da mensagem.

### Motivo para Utilizar Assinatura Digital:

üöÄ Utilizar a assinatura digital assegura que as mensagens recebidas s√£o aut√™nticas e n√£o foram alteradas, aumentando a seguran√ßa na comunica√ß√£o entre servidor e cliente.

### Implementa√ß√£o da Assinatura Digital:

üë®‚Äçüíª Criando um sistema de autentica√ß√£o de mensagens com Node.js.

Entendi, vamos expandir o tutorial para incluir a gera√ß√£o das chaves, salvando-as em arquivos, e utilizando-as tanto no backend quanto no frontend para a assinatura e verifica√ß√£o de mensagens.

## Parte 1: Backend em Node.js

### Gera√ß√£o e Armazenamento das Chaves

Primeiramente, vamos gerar o par de chaves e salv√°-las em arquivos separados.

1. **Crie um script para gerar as chaves**:

Nomeie o arquivo como `generateKeys.js` e adicione o seguinte c√≥digo:

```javascript
const { generateKeyPair } = require('crypto');
const fs = require('fs');
const path = require('path');

generateKeyPair('rsa', {
    modulusLength: 2048, // Tamanho da chave
}, (err, publicKey, privateKey) => {
    if (err) {
        console.error('Erro ao gerar as chaves:', err);
        return;
    }

    // Salvando a chave p√∫blica
    fs.writeFileSync(path.join(__dirname, 'publicKey.pem'), publicKey);

    // Salvando a chave privada
    fs.writeFileSync(path.join(__dirname, 'privateKey.pem'), privateKey);

    console.log('Chaves geradas e salvas.');
});
```

2. **Execute o script para gerar e salvar as chaves**:

No terminal, navegue at√© o diret√≥rio do seu projeto backend e execute:

```bash
node generateKeys.js
```

Isso criar√° dois arquivos: `publicKey.pem` e `privateKey.pem`, contendo a chave p√∫blica e privada, respectivamente.

### Implementa√ß√£o do Servidor com Assinaturas Digitais

Agora que temos as chaves, vamos modific√°-las `server.js` para assinar as informa√ß√µes usando a chave privada.

```javascript
const express = require('express');
const fs = require('fs');
const path = require('path');
const { createSign } = require('crypto');
const cors = require('cors')

const PORT = 3000;

const app = express();
app.use(cors())

const PRIVATE_KEY = fs.readFileSync(path.join(__dirname, 'privateKey.pem'), 'utf8');
const PUBLIC_KEY = fs.readFileSync(path.join(__dirname, 'publicKey.pem'), 'utf8');

// Rota para dados assinados
app.get('/data', (req, res) => {
  const data = { message: "Informa√ß√µes confidenciais do servidor" };

  const sign = createSign('sha256');
  sign.update(JSON.stringify(data));
  sign.end();
  const signature = sign.sign(PRIVATE_KEY, 'base64');

  res.json({ data, signature });
});

// Rota para servir a chave p√∫blica
app.get('/public-key', (req, res) => {
  res.send(PUBLIC_KEY);
});

app.listen(PORT, () => {
  console.log(`Servidor rodando na porta ${PORT}`);
});

```

## Vamos ajustar o tutorial para incluir a rota de retorno da chave p√∫blica no backend e utilizar `crypto-js` no frontend para a verifica√ß√£o da assinatura.

## Parte 1: Backend em Node.js

Primeiro, instale `cors` e `express` no seu projeto:

```bash
npm install cors express
```


### Adicionando uma Rota para a Chave P√∫blica

No seu arquivo `server.js`, adicione uma nova rota para servir a chave p√∫blica:

```javascript
const express = require('express');
const fs = require('fs');
const path = require('path');
const { createSign, createVerify  } = require('crypto');
const cors = require('cors')

const PORT = 3000;

const app = express();
app.use(express.json());
app.use(cors())

const PRIVATE_KEY = fs.readFileSync(path.join(__dirname, 'privateKey.pem'), 'utf8');
const PUBLIC_KEY = fs.readFileSync(path.join(__dirname, 'publicKey.pem'), 'utf8');

// Rota para dados assinados
app.get('/data', (req, res) => {
  const data = { message: "Informa√ß√µes confidenciais do servidor" };

  const sign = createSign('sha256');
  sign.update(JSON.stringify(data));
  sign.end();
  const signature = sign.sign(PRIVATE_KEY, 'base64');

  res.json({ data, signature });
});

// Rota para servir a chave p√∫blica
app.get('/public-key', (req, res) => {
  res.send(PUBLIC_KEY);
});

app.post('/validate-signature', (req, res) => {
  const { data, signature, publicKey } = req.body;

  // Converte os dados de volta para string, se necess√°rio
  const dataString = JSON.stringify(data);

  const verify = createVerify('sha256');
  verify.update(dataString);
  verify.end();

  // A assinatura precisa ser convertida de Base64 para formato bin√°rio
  const isSignatureValid = verify.verify(publicKey, signature, 'base64');

  if (isSignatureValid) {
    res.json({ valid: true, message: "A assinatura √© v√°lida." });
  } else {
    res.status(400).json({ valid: false, message: "A assinatura √© inv√°lida." });
  }
});

app.listen(PORT, () => {
  console.log(`Servidor rodando na porta ${PORT}`);
});
```

## Parte 2: Frontend em React

Para o frontend, vamos atualizar o React para utilizar `crypto-js` para a decodifica√ß√£o da assinatura base64 e a verifica√ß√£o da assinatura com a chave p√∫blica obtida do backend.

### Componente `VerifyData.js`

Agora, vamos modificar o componente `VerifyData.js` para obter a chave p√∫blica do servidor e verificar a assinatura das informa√ß√µes recebidas:

```jsx
import React, { useState } from 'react';
import axios from 'axios';
import './App.css'

function App() {
  const [dataStatus, setDataStatus] = useState("Dados n√£o verificados.");
  const [message, setMessage] = useState("");

  // Fun√ß√£o para buscar a chave p√∫blica do servidor
  const fetchPublicKey = async () => {
    try {
      const response = await axios.get('http://localhost:3000/public-key');
      return response.data;
    } catch (error) {
      console.error('Erro ao obter a chave p√∫blica:', error);
    }
  };

  // Fun√ß√£o para buscar os dados assinados do servidor
  const fetchData = async () => {
    try {
      const response = await axios.get('http://localhost:3000/data');
      return response.data;
    } catch (error) {
      console.error('Erro ao buscar dados:', error);
    }
  };

  // Fun√ß√£o para validar os dados usando a chave p√∫blica
  const validateData = async () => {
    const publicKey = await fetchPublicKey();
    const { data, signature } = await fetchData();

    // Enviar os dados e a assinatura para o servidor para valida√ß√£o
    const validationResponse = await axios.post('http://localhost:3000/validate-signature', {
      data: data,
      publicKey,
      signature: signature
    });

    const isValid = validationResponse;

    if (isValid) {
      setDataStatus("Dados verificados e seguros.");
      setMessage(data.message);
    } else {
      setDataStatus("Dados n√£o s√£o seguros.");
    }
  };

  return (
    <div className="App">
      <h1>Status dos Dados: {dataStatus}</h1>
      {message && <p>Mensagem do Servidor: {message}</p>}
      <button onClick={validateData}>Validar Autenticidade dos Dados</button>
    </div>
  );
}

export default App;
```

### üîç Testes:

1. **Envio e Verifica√ß√£o**:
    
    - Assine uma mensagem e envie-a junto com a assinatura.
    - O receptor usa a chave p√∫blica para verificar a assinatura e validar a mensagem.

## üèÜ Conclus√£o

A assinatura digital √© uma ferramenta poderosa para garantir a seguran√ßa das comunica√ß√µes digitais, oferecendo integridade, autenticidade e n√£o-rep√∫dio. Este tutorial forneceu um exemplo b√°sico de como implementar assinaturas digitais em Node.js, demonstrando a gera√ß√£o de chaves, assinatura de mensagens e verifica√ß√£o de assinaturas. Implementar essas t√©cnicas em suas aplica√ß√µes pode significativamente aumentar a seguran√ßa e a confiabilidade das comunica√ß√µes entre servidores e clientes. Continue explorando e implementando recursos de seguran√ßa para proteger suas aplica√ß√µes! üîêüíª
